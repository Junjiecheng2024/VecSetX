â€œä½ ç°åœ¨è¿™ç§åšæ³•ï¼Œå°±æ˜¯æŠŠæ‰€æœ‰ç‚¹ä¸€èµ·è¾“è¿›å»ï¼Œç„¶åå‘Šè¯‰å®ƒä¸€ä¸ª one-hotï¼Œè®©å®ƒè‡ªå·±å»å­¦ã€‚â€

â€œè¿™ä¸ªåœ¨å¤šç±» implicitã€å°¤å…¶æ˜¯ SDF è¿™é‡Œï¼Œæ˜¯å¾ˆæœ‰å¯èƒ½ä¸æˆç«‹çš„ã€‚â€

â€œå› ä¸ºä½ çš„ SDF åœ¨å¤šç±»æƒ…å†µä¸‹æ˜¯æœ‰è·³å˜çš„ï¼Œä½ è¿™ä¸ª loss æœ¬èº«å°±å¾ˆå¯èƒ½æ˜¯æœ‰ bug çš„ã€‚â€

â€œè¿™ä¸ªä¸æ˜¯è°ƒå‚é—®é¢˜ï¼Œæ˜¯å»ºæ¨¡å‡è®¾çš„é—®é¢˜ã€‚â€
â€œæˆ‘ä»¬ä¹‹å‰åœ¨å¦å¤–ä¸€ä¸ª project é‡Œé¢ï¼Œå…¶å®è¯•è¿‡è¿™ä¸ªäº‹æƒ…ã€‚â€

â€œå½“æ—¶æœ‰ä¸€ä¸ªåšå£«å­¦å¼Ÿï¼Œä»–ä¹Ÿè¯•è¿‡ä½ è¿™ç§ one-hot çš„ multi-class implicitã€‚â€

â€œä½†ä»–æœ€åè·‘ä¸‹æ¥ï¼Œæ•ˆæœæœ€å¥½çš„ï¼Œå¹¶ä¸æ˜¯è¿™ç§åšæ³•ã€‚â€

â€œä»–æ•ˆæœæœ€å¥½çš„åšæ³•æ˜¯ï¼šâ€

â€œæ¯”å¦‚æˆ‘æœ‰åä¸ªç±»åˆ«ï¼Œæˆ‘ä¸æ˜¯æŠŠæ‰€æœ‰ç‚¹æ··åœ¨ä¸€èµ·è¾“ã€‚â€

â€œè€Œæ˜¯æ¯ä¸€ä¸ªç±»åˆ«ï¼Œå•ç‹¬æŠŠå®ƒè‡ªå·±çš„ç‚¹è¾“è¿› transformerã€‚â€

â€œä½†æ˜¯ transformer æ˜¯å…±ç”¨çš„ã€‚â€

â€œä¹Ÿå°±æ˜¯è¯´ï¼Œclass 1 çš„ç‚¹ï¼Œå•ç‹¬ forward ä¸€æ¬¡ï¼›class 2 çš„ç‚¹ï¼Œå† forward ä¸€æ¬¡ã€‚â€

â€œæ¯ä¸€ä¸ªç±»åˆ«ï¼Œå…¶å®ä½ å¯ä»¥æŠŠå®ƒçœ‹æˆä¸€ä¸ª binary taskã€‚â€

â€œå®ƒä»¬å…±äº«åŒä¸€ä¸ª transformerï¼Œä½† loss æ˜¯å„ç®—å„çš„ã€‚â€

â€œè¿™ä¸ªç»“æœæ˜¯æ˜æ˜¾æ¯” one-hot é‚£ç§æ–¹å¼è¦å¥½ä¸€å¤§æˆªã€‚â€

â€œè€Œä¸”è¿™ä¸ªä¸æ˜¯åªåœ¨ä¸€ä¸ª case ä¸Šçœ‹åˆ°çš„ï¼Œæ˜¯æ•´ä½“éƒ½æ›´ç¨³å®šã€‚â€

â€œè¿™ç§åšæ³•çš„å¥½å¤„åœ¨äºï¼Œä¸åŒç±»åˆ«çš„ç‚¹ä¸ä¼šåœ¨ attention é‡Œé¢äº’ç›¸å¹²æ‰°ã€‚â€

â€œå®ƒå­¦çš„æ˜¯åŒä¸€ç±»ç»“æ„å†…éƒ¨çš„å‡ ä½•å…³ç³»ï¼Œè€Œä¸æ˜¯å¼ºè¡ŒæŠŠæ‰€æœ‰ç»“æ„æ··åœ¨ä¸€èµ·ã€‚â€

â€œä½ å¯ä»¥è®¤ä¸º transformer å­¦çš„æ˜¯â€˜æ€ä¹ˆçœ‹ç‚¹â€™ï¼Œè€Œä¸æ˜¯â€˜è¿™æ˜¯å“ªä¸€ç±»â€™ã€‚â€

â€œç±»åˆ«çš„ä¿¡æ¯ï¼Œä¸éœ€è¦é€šè¿‡è¾“å…¥ç»´åº¦ç»™å®ƒã€‚â€

â€œæˆ‘å»ºè®®ä½ å…ˆä¸è¦çº ç»“å¤šç±»ï¼Œå…ˆè·‘ä¸€ä¸ªå•ç±»ã€‚â€

â€œå•ç±»è·‘é€šä¹‹åï¼Œå†ç”¨è¿™ç§æ–¹å¼æ‰©å±•åˆ°å¤šç±»ã€‚â€

â€œå¤šç±»çš„æ—¶å€™ï¼Œå°±æ˜¯ for loop over classesï¼Œå…±ç”¨ transformerã€‚â€

â€œè¿™ä¸ª baseline æ˜¯è‚¯å®šæˆç«‹çš„ã€‚â€

â€œç±»åˆ«ä¹‹é—´çš„å…³ç³»ï¼Œæ˜¯åé¢å†æƒ³çš„äº‹æƒ…ã€‚â€



# ä½ ç°åœ¨çš„æ•°æ®å‡†å¤‡åº”è¯¥æ€ä¹ˆåšï¼ˆæœ€ç»ˆç‰ˆï¼‰

> **ç›®æ ‡ä¸€å¥è¯**ï¼š
> æŠŠâ€œå¤šç±»åˆ†å‰²æ•°æ®â€æ•´ç†æˆ **ã€Œæ¯ä¸ªç±»åˆ« = ä¸€ä¸ª binary implicit ä»»åŠ¡ã€**ï¼Œ
> **ä¸ä½¿ç”¨ one-hotï¼Œä¸å¢åŠ ç‚¹çš„è¾“å…¥ç»´åº¦ï¼Œåªç”¨ç‚¹çš„â€œæ¥æºâ€å’Œâ€œä½ç½®â€åŒºåˆ†ç±»åˆ«ã€‚**

---

## ä¸€ã€æ€»ä½“åŸåˆ™ï¼ˆå…ˆè®°ä½è¿™ 4 æ¡ï¼‰

1. **VecSetX çš„ encoder è¾“å…¥ä»ç„¶æ˜¯ `(B, N, 3)`**
2. **ç‚¹æœ¬èº«ä¸æºå¸¦ç±»åˆ«ä¿¡æ¯**
3. **ç±»åˆ«ç”±â€œè¿™æ‰¹ç‚¹æ¥è‡ªå“ªä¸ªé›†åˆâ€æ¥éšå¼å†³å®š**
4. **loss æ°¸è¿œæ˜¯â€œæŒ‰ç±»åˆ«å•ç‹¬ç®—â€çš„**

---

## äºŒã€æ¯ä¸ª case çš„æ•°æ®ç»“æ„ï¼ˆä½ è¦å­˜æˆè¿™æ ·ï¼‰

å¯¹ **æ¯ä¸€ä¸ª case**ï¼Œä½ è¦æŒ‰â€œç±»åˆ«â€æ‹†å¼€å­˜ç‚¹ï¼š

```text
case_xxx/
 â”œâ”€â”€ class_1/
 â”‚    â”œâ”€â”€ surface_pts.npy        (N1s, 3)
 â”‚    â”œâ”€â”€ near_surface_pts.npy   (N1n, 3)
 â”‚    â”œâ”€â”€ volume_pts.npy         (N1v, 3)
 â”‚    â””â”€â”€ target.npy             (N1, 1)   # sdf æˆ– occ
 â”‚
 â”œâ”€â”€ class_2/
 â”‚    â”œâ”€â”€ surface_pts.npy
 â”‚    â”œâ”€â”€ near_surface_pts.npy
 â”‚    â”œâ”€â”€ volume_pts.npy
 â”‚    â””â”€â”€ target.npy
 â”‚
 â””â”€â”€ ...
```

### å…³é”®ç‚¹ï¼ˆéå¸¸é‡è¦ï¼‰ï¼š

* **æ¯ä¸ª class æ˜¯å®Œå…¨ç‹¬ç«‹çš„ä¸€å¥—ç‚¹**
* target **åªå’Œè¿™ä¸ª class æœ‰å…³**
* **ä¸å…è®¸**ï¼š

  * ä¸€ä¸ªç‚¹åŒæ—¶å±äºå¤šä¸ª class
  * ä¸€ä¸ªç‚¹çš„ target æ··åˆå¤šä¸ª class çš„ SDF

---

## ä¸‰ã€ç‚¹æ˜¯æ€ä¹ˆé‡‡æ ·çš„ï¼ˆæŒ‰ç±»åˆ«æ¥ï¼‰

å¯¹æ¯ä¸€ä¸ª **ç±»åˆ« c**ï¼Œä½ å•ç‹¬åšï¼š

1. **è¡¨é¢ç‚¹ï¼ˆsurfaceï¼‰**

   * ä»è¯¥ç±»åˆ«çš„ mask è¡¨é¢é‡‡æ ·
2. **è¿‘è¡¨é¢ç‚¹ï¼ˆnear-surfaceï¼‰**

   * è¡¨é¢å†…å¤–ä¸€å®šè·ç¦»å†…é‡‡æ ·
3. **ä½“ç§¯ç‚¹ï¼ˆvolume / uniformï¼‰**

   * åœ¨æ•´ä¸ª volume ä¸­é‡‡æ ·ï¼ˆinside + outsideï¼‰

ç„¶åï¼š

```python
pts_c = concat(
    surface_pts_c,
    near_surface_pts_c,
    volume_pts_c
)  # shape: (Nc, 3)
```

ğŸ‘‰ è¿™ä¸€æ­¥ **å®Œå…¨å¤ç”¨ VecSetX åŸæœ¬çš„é‡‡æ ·é€»è¾‘**
ğŸ‘‰ åªæ˜¯ **ä»â€œå…¨å±€ä¸€æ¬¡é‡‡æ ·â€å˜æˆâ€œæ¯ä¸ªç±»åˆ«å„é‡‡ä¸€å¥—â€**

---

## å››ã€target åº”è¯¥æ€ä¹ˆå­˜ï¼ˆè¿™æ˜¯å¸¸è§å‘ï¼‰

### å¦‚æœä½ ç”¨çš„æ˜¯ **SDF**ï¼š

* `target_c[i] = signed_distance( point_i , surface_of_class_c )`
* **åªå¯¹ class c å®šä¹‰**
* ä¸å…³å¿ƒå…¶ä»–ç±»åˆ«

### å¦‚æœä½ ç”¨çš„æ˜¯ **occupancy**ï¼š

* `target_c[i] = 1` if point inside class c
* å¦åˆ™ `0`

âš ï¸ é‡è¦æé†’ï¼š

> **ä¸è¦å­˜ä¸€ä¸ª `(N, K)` çš„å¤šç±» SDF / occ**
> ä½ ç°åœ¨è¦çš„æ˜¯ **K ä¸ª `(Nc, 1)` çš„ binary target**

---

## äº”ã€è®­ç»ƒæ—¶æ•°æ®æ˜¯æ€ä¹ˆè¢«ç”¨çš„ï¼ˆä½ å¯¹é½ä¸€ä¸‹ï¼‰

è®­ç»ƒ loop çš„é€»è¾‘åº”è¯¥æ˜¯ï¼š

```python
for c in classes:
    pts   = load_pts(case, c)      # (B, Nc, 3)
    gt    = load_target(case, c)   # (B, Nc, 1)

    pred  = model(pts)             # VecSetX encoder + decoder
    loss += loss_fn(pred, gt)
```

ä½ å¯ä»¥å¯¹ç…§ä¸€ä¸‹ä½ ç°åœ¨ä»£ç é‡Œï¼š

* âŒ æœ‰æ²¡æœ‰ one-hot â†’ **åº”è¯¥åˆ æ‰**
* âŒ æœ‰æ²¡æœ‰ä¸€æ¬¡ forward æ·· 10 ç±» â†’ **ä¸åº”è¯¥**
* âœ… æœ‰æ²¡æœ‰ for-loop over classes â†’ **åº”è¯¥æœ‰**

---

## å…­ã€å“ªäº›ä¸œè¥¿ä½ ç°åœ¨å¯ä»¥ã€Œä¸ç®¡ã€

ä¸ºäº†é˜²æ­¢ä½ è¿‡åº¦å¤æ‚åŒ–ï¼Œç°åœ¨è¿™äº›éƒ½**å…ˆåˆ«åš**ï¼š

* âŒ ç±»åˆ« embedding
* âŒ class token
* âŒ multi-head è¾“å‡º
* âŒ ç±»åˆ«ä¹‹é—´çš„çº¦æŸ / overlap loss
* âŒ attention mask

ğŸ‘‰ **å¯¼å¸ˆè¦ä½ å…ˆè·‘é€šçš„æ˜¯è¿™ä¸ªæœ€å¹²å‡€çš„ baseline**

---

## ä¸ƒã€å®Œæˆåˆ°ä»€ä¹ˆç¨‹åº¦ï¼Œç®—ä½ â€œè¿™ä¸€æ­¥å¯¹äº†â€ï¼Ÿ

ä½ å¯ä»¥ç”¨è¿™ 5 æ¡è‡ªæ£€ï¼š

1. encoder è¾“å…¥ä»æ˜¯ `(B, N, 3)`
2. æ•°æ®æ–‡ä»¶é‡Œ **æ²¡æœ‰ one-hot**
3. æ¯ä¸ª class éƒ½èƒ½å•ç‹¬è·‘ä¸€ä¸ª implicit
4. SDF / occ loss åœ¨æ•°å­¦ä¸Šæ˜¯æˆç«‹çš„
5. å•ç±»ç»“æœçœ‹èµ·æ¥åˆç†ï¼Œå†æ‰©åˆ°å¤šç±»

åªè¦è¿™ 5 æ¡éƒ½æ»¡è¶³ï¼Œ**ä½ ç°åœ¨çš„æ•°æ®å‡†å¤‡å°±æ˜¯å®Œå…¨å¯¹çš„**ã€‚

---

## å…«ã€ç»™ä½ ä¸€å¥â€œå¯¼å¸ˆè§†è§’çš„æ€»ç»“å¥â€

ä½ ä»¥åæ±‡æŠ¥ã€å†™ note éƒ½å¯ä»¥ç›´æ¥ç”¨ï¼š

> **â€œWe reorganize the data such that each anatomical structure is treated as an independent binary implicit task. Class information is encoded implicitly by data grouping rather than explicit one-hot encoding.â€**

---
